DECLARE @Delimiter NVARCHAR(1) = '|';  -- The delimiter used in your string
DECLARE @TableName NVARCHAR(128) = 'your_table';  -- Your table name
DECLARE @ColumnName NVARCHAR(128) = 'full_name';  -- The column you want to split
DECLARE @ReferenceTable NVARCHAR(128) = 'reference_table';  -- The reference table to check matches
DECLARE @ReferenceColumn NVARCHAR(128) = 'reference_column';  -- The reference column to match with parts
DECLARE @SQL NVARCHAR(MAX);
DECLARE @MaxParts INT;

-- Step 1: Find the maximum number of parts in the string
SELECT @MaxParts = MAX(LEN(full_name) - LEN(REPLACE(full_name, @Delimiter, '')) + 1)
FROM your_table;

-- Step 2: Generate dynamic SQL to split and pivot the results and place them in a CTE
SET @SQL = 'WITH SplitValues AS (
    SELECT ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY (SELECT NULL)) AS part_number, 
           s.value AS part_value,
           t.id
    FROM ' + @TableName + ' t
    CROSS APPLY STRING_SPLIT(t.' + @ColumnName + ', ''' + @Delimiter + ''') s
), FinalTable AS (
    SELECT id';

-- Step 3: Dynamically add columns for each part and match with reference table
DECLARE @i INT = 1;
WHILE @i <= @MaxParts
BEGIN
    -- Add the part columns
    SET @SQL = @SQL + ', MAX(CASE WHEN part_number = ' + CAST(@i AS NVARCHAR) + ' THEN part_value END) AS part' + CAST(@i AS NVARCHAR);
    
    -- Add the match columns to check against reference_table
    SET @SQL = @SQL + ', MAX(CASE WHEN part_number = ' + CAST(@i AS NVARCHAR) + 
                ' AND EXISTS (SELECT 1 FROM ' + @ReferenceTable + ' r WHERE r.' + @ReferenceColumn + 
                ' = part_value) THEN 1 ELSE 0 END) AS part' + CAST(@i AS NVARCHAR) + '_match';
    
    SET @i = @i + 1;
END

SET @SQL = @SQL + ' FROM SplitValues GROUP BY id
)
-- Step 4: Use the CTE to select or further manipulate data
SELECT * FROM FinalTable;';

-- Step 5: Execute the dynamic SQL
EXEC sp_executesql @SQL;
