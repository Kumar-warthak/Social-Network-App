DECLARE @Delimiter NVARCHAR(1) = '|';  -- The delimiter used in your string
DECLARE @TableName NVARCHAR(128) = 'your_table';  -- Your table name
DECLARE @ColumnName NVARCHAR(128) = 'full_name';  -- The column you want to split
DECLARE @ReferenceTable NVARCHAR(128) = 'reference_table';  -- The reference table to check matches
DECLARE @ReferenceColumn NVARCHAR(128) = 'reference_column';  -- The reference column to match with parts
DECLARE @SQL NVARCHAR(MAX);
DECLARE @MaxParts INT;

-- Step 1: Find the maximum number of parts in the string
SELECT @MaxParts = MAX(LEN(full_name) - LEN(REPLACE(full_name, @Delimiter, '')) + 1)
FROM your_table;

-- Step 2: Generate dynamic SQL to split and pivot the results and place them in a CTE
SET @SQL = 'WITH SplitValues AS (
    SELECT ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY (SELECT NULL)) AS part_number, 
           s.value AS part_value,
           t.id,
           CASE WHEN r.' + @ReferenceColumn + ' IS NOT NULL THEN ''Match'' ELSE ''NoMatch'' END AS match_found
    FROM ' + @TableName + ' t
    CROSS APPLY STRING_SPLIT(t.' + @ColumnName + ', ''' + @Delimiter + ''') s
    LEFT JOIN ' + @ReferenceTable + ' r ON s.value = r.' + @ReferenceColumn + '
), FinalTable AS (
    SELECT id';

-- Step 3: Dynamically add columns for each part and the match columns
DECLARE @i INT = 1;
WHILE @i <= @MaxParts
BEGIN
    -- Add the part columns
    SET @SQL = @SQL + ', MAX(CASE WHEN part_number = ' + CAST(@i AS NVARCHAR) + ' THEN part_value END) AS part' + CAST(@i AS NVARCHAR);
    
    -- Add the match columns
    SET @SQL = @SQL + ', MAX(CASE WHEN part_number = ' + CAST(@i AS NVARCHAR) + ' THEN match_found END) AS part' + CAST(@i AS NVARCHAR) + '_match';
    
    SET @i = @i + 1;
END

SET @SQL = @SQL + ', 
    CASE 
        WHEN ';

-- Step 4: Add logic to check if any match columns have "Match"
SET @i = 1;
WHILE @i <= @MaxParts
BEGIN
    SET @SQL = @SQL + ' MAX(CASE WHEN part_number = ' + CAST(@i AS NVARCHAR) + ' THEN match_found END) = ''Match'' OR';
    SET @i = @i + 1;
END

-- Remove the last 'OR' and finalize the CASE statement
SET @SQL = LEFT(@SQL, LEN(@SQL) - 2) + ' THEN ''Match'' ELSE ''NoMatch'' END AS overall_match';

SET @SQL = @SQL + ' FROM SplitValues GROUP BY id
)
-- Step 5: Use the CTE to select or further manipulate data
SELECT * FROM FinalTable;';

-- Step 6: Execute the dynamic SQL
EXEC sp_executesql @SQL;
